# Default values for phpmyadmin.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass
##
# global:
#   imageRegistry: myRegistryName
#   imagePullSecrets:
#     - myRegistryKeySecretName
#   storageClass: myStorageClass

## String to partially override phpmyadmin.fullname template (will maintain the release name)
##
# nameOverride: ""

## String to fully override phpmyadmin.fullname template
##
# fullnameOverride: ""

## Add labels to all the deployed resources
##
commonLabels: {}

## Add annotations to all the deployed resources
##
commonAnnotations: {}

## Kubernetes Cluster Domain
##
clusterDomain: cluster.local

## Extra objects to deploy (value evaluated as a template)
##
extraDeploy: []

## Number of phpMyAdmin replicas to deploy
##
replicaCount: 1

## phpMyAdmin image
## ref: https://hub.docker.com/_/phpmyadmin/
##
image:
  registry: docker.io
  repository: phpmyadmin
  tag: "5.2.2-apache"
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
  ##
  pullPolicy: IfNotPresent
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ## e.g:
  ## pullSecrets:
  ##   - myRegistryKeySecretName
  ##
  pullSecrets: []

## Container port configuration
##
containerPorts:
  http: 80

## Database configuration
##
db:
  ## Enable connection to an arbitrary server
  ##
  allowArbitraryServer: false
  
  ## Database host
  ##
  host: website-db-mysql-master
  
  ## Database port
  ##
  port: 3306
  
  ## Database user (leave empty to use environment variable)
  ##
  user: ""
  
  ## Database password (leave empty to use environment variable)
  ##
  password: ""
  
  ## Existing secret containing database credentials
  ## Keys: mysql-username, mysql-password
  ##
  existingSecret: ""

## phpMyAdmin authentication configuration
##
auth:
  ## Existing secret containing phpMyAdmin credentials
  ## Keys: phpmyadmin-password
  ##
  existingSecret: ""
  
  ## phpMyAdmin admin password
  ##
  password: ""

## Configure extra environment variables
##
extraEnvVars: []
## Example:
## extraEnvVars:
##   - name: PMA_ARBITRARY
##     value: "1"

## Configure extra environment variables from existing ConfigMap or Secret
##
extraEnvVarsCM: ""
extraEnvVarsSecret: ""

## Configure Container Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
## Note: phpMyAdmin official image runs as root, so we need to allow that
##
containerSecurityContext:
  enabled: true
  runAsUser: 0
  runAsNonRoot: false
  privileged: false
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false
  capabilities:
    drop: ["ALL"]
    add: ["CHOWN", "DAC_OVERRIDE", "FOWNER", "SETGID", "SETUID"]
  seccompProfile:
    type: "RuntimeDefault"

## Configure Pod Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
## Note: phpMyAdmin official image runs as root, so we disable pod security context
##
podSecurityContext:
  enabled: false
  fsGroup: 1001

## phpMyAdmin pods' resource requests and limits
## ref: http://kubernetes.io/docs/user-guide/compute-resources/
##
resources:
  limits: {}
  requests: {}

## Configure the liveness probe
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
##
livenessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 6
  httpGet:
    path: /
    port: http

## Configure the readiness probe
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
##
readinessProbe:
  enabled: true
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 3
  httpGet:
    path: /
    port: http

## Configure the startup probe
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
##
startupProbe:
  enabled: false
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 15
  httpGet:
    path: /
    port: http

## Custom liveness probe that overrides the default one
##
customLivenessProbe: {}

## Custom readiness probe that overrides the default one
##
customReadinessProbe: {}

## Custom startup probe that overrides the default one
##
customStartupProbe: {}

## phpMyAdmin pods' affinity
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
##
affinity: {}

## Pod anti-affinity configuration
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
##
podAntiAffinity:
  ## Enable pod anti-affinity
  ##
  enabled: false
  
  ## Set the type of anti-affinity: hard or soft
  ## hard: requiredDuringSchedulingIgnoredDuringExecution
  ## soft: preferredDuringSchedulingIgnoredDuringExecution
  ##
  type: soft
  
  ## Set the topology key for anti-affinity
  ## Common values: kubernetes.io/hostname, topology.kubernetes.io/zone, failure-domain.beta.kubernetes.io/zone
  ##
  topologyKey: kubernetes.io/hostname

## Node labels for phpMyAdmin pods assignment
## ref: https://kubernetes.io/docs/user-guide/node-selection/
##
nodeSelector: {}

## Tolerations for phpMyAdmin pods assignment
## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
##
tolerations: []

## phpMyAdmin pods' priorityClassName
##
priorityClassName: ""

## phpMyAdmin pods' schedulerName
##
schedulerName: ""

## Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in.
## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
##
topologySpreadConstraints: []

## Name of the k8s service account to use for the pods
## If not set and serviceAccount.create is true
## a name is generated using the fullname template
##
serviceAccount:
  ## Determine whether a Service Account should be created or it should reuse a exiting one.
  ##
  create: true
  ## The name of the ServiceAccount to use.
  ## If not set and create is true, a name is generated using the fullname template
  ##
  name: ""
  ## Additional Service Account annotations
  ##
  annotations: {}
  ## Automount API credentials for a service account.
  ##
  automountServiceAccountToken: true

## Pod disruption budget configuration
##
podDisruptionBudget:
  ## Specifies whether a Pod disruption budget should be created
  ##
  create: true
  # minAvailable: 1
  maxUnavailable: 1

## Kubernetes service to expose phpMyAdmin
##
service:
  ## Kubernetes service type
  ##
  type: ClusterIP
  ## phpMyAdmin service port
  ##
  port: 80
  ## Control hosts connecting to "LoadBalancer" only
  ##
  loadBalancerSourceRanges: []
  ## phpMyAdmin service Cluster IP
  ## e.g.:
  ## clusterIP: None
  ##
  clusterIP: ""
  ## Specify the nodePort value for the LoadBalancer and NodePort service types.
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  ##
  # nodePort: 30080
  ## Set the LoadBalancer service type to internal only.
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
  ##
  # loadBalancerIP: ""
  ## Provide any additional annotations which may be required.
  ##
  annotations: {}
  ## Set the service sessionAffinity. Valid values are None and ClientIP
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  ##
  sessionAffinity: None
  ## sessionAffinityConfig contains the configurations of session affinity
  ##
  sessionAffinityConfig: {}

## Configure the ingress resource that allows you to access the phpMyAdmin
## ref: http://kubernetes.io/docs/user-guide/ingress/
##
ingress:
  ## Set to true to enable ingress record generation
  ##
  enabled: true
  
  ## IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
  ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#deprecated-annotation
  ##
  ingressClassName: haproxy-internal
  
  ## When the ingress is enabled, a host pointing to this will be created
  ##
  hostname: website-pma.cannes.gw.oxv.fr
  
  ## The Path to phpMyAdmin. You may need to set this to '/*' in order to use this with ALB ingress controllers.
  ##
  path: /
  
  ## Ingress path type
  ##
  pathType: Prefix
  
  ## Override API Version (automatically detected if not set)
  ##
  apiVersion: ""
  
  ## Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
  ## For a full list of possible ingress annotations, please see
  ## ref: https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md
  ## Use this parameter to set the required annotations for cert-manager, see
  ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
  ##
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-internal
    haproxy.org/allow-list: 82.66.250.240,51.210.177.245
  
  ## Enable TLS configuration for the hostname defined at ingress.hostname parameter
  ## TLS certificates will be retrieved from a TLS secret with name: {{- printf "%s-tls" .Values.ingress.hostname }}
  ## You can use the ingress.secrets parameter to create this TLS secret or relay on cert-manager to create it
  ##
  tls: true
  
  ## The list of additional hostnames to be covered with this ingress record.
  ## Most likely the hostname above will be enough, but in the event more hosts are needed, this is an array
  ## hosts:
  ##   - name: phpmyadmin.local
  ##     path: /
  ##
  extraHosts: []
  
  ## The tls configuration for additional hostnames to be covered with this ingress record.
  ## see: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  ## extraTls:
  ## - hosts:
  ##   - phpmyadmin.local
  ##   secretName: phpmyadmin.local-tls
  ##
  extraTls: []
  
  ## If you're providing your own certificates, please use this to add the certificates as secrets
  ## key and certificate should start with -----BEGIN CERTIFICATE----- or -----BEGIN RSA PRIVATE KEY-----
  ## name should line up with a secretName set further up
  ## If it is not set and you're using cert-manager, this is unneeded, as it will create the secret for you
  ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created
  ## It is also possible to create and manage the certificates outside of this helm chart
  ## Please see README.md for more information
  ## Example:
  ## secrets:
  ##   - name: phpmyadmin.local-tls
  ##     key: ""
  ##     certificate: ""
  ##
  secrets: []
  
  ## Override the ingress class name
  ##
  # className: ""

## Persistence Parameters
## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
##
persistence:
  enabled: false
  ## A manually managed Persistent Volume and Claim
  ## If defined, PVC must be created manually before volume will be bound
  ##
  # existingClaim: ""
  ## The path the volume will be mounted at, useful when using different
  ## Redis images.
  ##
  mountPath: /data
  ## The subdirectory of the volume to mount to, useful in dev environments
  ## and one PV for multiple services.
  ##
  subPath: ""
  ## phpMyAdmin data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  # storageClass: "-"
  ## Persistent Volume Access Mode
  ##
  accessModes:
    - ReadWriteOnce
  ## Persistent Volume size
  ##
  size: 8Gi
  ## The name of an existing PVC to use for persistence
  ##
  # existingClaim: ""
  ## Persistent Volume Claim annotations
  ##
  annotations: {}
  ## Selector to match an existing Persistent Volume for phpMyAdmin data
  ## If set, the PVC can't have a PV dynamically provisioned for it
  ## E.g.
  ## selector:
  ##   matchLabels:
  ##     app: my-app
  ##
  selector: {}

## Init containers to run before the main container starts.
## ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
## e.g:
## initContainers:
##  - name: your-image-name
##    image: your-image
##    imagePullPolicy: Always
##    command: ['sh', '-c', 'echo "hello world"']
##
initContainers: []

## Additional containers to run along side the main container.
## e.g:
## sidecars:
##  - name: your-image-name
##    image: your-image
##    imagePullPolicy: Always
##    ports:
##    - name: portname
##      containerPort: 1234
##
sidecars: []

## Extra volumes to add to the phpMyAdmin statefulset
##
extraVolumes:
- name: config-inc-php
  configMap:
    name: config-inc-php

## Extra volume mounts to add to the phpMyAdmin container
##
extraVolumeMounts:
- name: config-inc-php
  mountPath: /opt/bitnami/phpmyadmin/config.inc.php
  subPath: config.inc.php

## ConfigMap with scripts to be run at first boot
## NOTE: This will override other scripts
##
# initdbScriptsConfigMap: ""

## Secret with scripts to be run at first boot (in case it contains sensitive information)
## NOTE: This can work along initdbScriptsConfigMap
##
# initdbScriptsSecret: ""

## Specify the number of seconds you want to wait for your app to start up before checking health.
## https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
##
# initialDelaySeconds: 30

## Pod annotations
## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
##
podAnnotations: {}

## Pod labels
## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
##
podLabels: {}

## updateStrategy for phpMyAdmin statefulset
## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
##
updateStrategy:
  type: RollingUpdate

## phpMyAdmin pod management policy
##
# podManagementPolicy: OrderedReady

## Autoscaling configuration
##
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 11
  targetCPU: 50
  targetMemory: 50

## Network Policy configuration
## Ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
##
networkPolicy:
  ## Specifies whether a NetworkPolicy should be created
  ##
  enabled: true
  
  ## The Policy model to apply. When set to false, only pods with the correct
  ## client label will have network access to the ports phpMyAdmin is listening
  ## on. When true, phpMyAdmin will accept connections from any source
  ## (with the correct destination port).
  ##
  allowExternal: true
  
  ## Allow the pod to access any range of port and all destinations.
  ##
  allowExternalEgress: true
  
  ## Allow connection from pods with specific labels in the same namespace
  ## Example:
  ## ingressNSMatchLabels:
  ##   name: "ingress-nginx"
  ##
  ingressNSMatchLabels: {}
  
  ## Allow connection from pods with specific labels in a specific namespace
  ## Example:
  ## ingressNSPodMatchLabels:
  ##   app: "ingress-nginx"
  ##
  ingressNSPodMatchLabels: {}
  
  ## Database pod selector for egress rules
  ## Example:
  ## databaseSelector:
  ##   app: "mysql"
  ##   component: "primary"
  ##
  databaseSelector: {}
  
  ## Extra egress rules to be applied to the NetworkPolicy
  ## e.g:
  ## extraEgress:
  ##   - to:
  ##       - podSelector:
  ##           matchLabels:
  ##             app: external-service
  ##     ports:
  ##       - port: 443
  ##         protocol: TCP
  ##
  extraEgress: []
  
  ## Custom network policy rules
  ## e.g:
  ## customRules:
  ##   - from:
  ##       - podSelector:
  ##           matchLabels:
  ##             app: "custom-app"
  ##     ports:
  ##       - port: 80
  ##         protocol: TCP
  ##
  customRules: []